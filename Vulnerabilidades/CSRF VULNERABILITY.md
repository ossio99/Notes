# CSRF VULNERABILITY

Esta vulnerabilidad es para sesiones

Al enviar un formulario se envían con todo y cookies

Framework con baterías incluidas

Cors no es suficiente ya que no permite hacer la respuesta pero si la petición y ejecutar esta misma

Formularios no siguen las reglas de cors

Podemos hacer peticiones con fetch y hacerlas pasar por formularios cambiando el content type en la cabecera de la petición 

De igual forma podemos decirle que incluya las cookies que tiene almacenado el navegador en la petición con la propiedad credentials: include en el objeto de configuración de la petición 

![Untitled](CSRF%20VULNERABILITY/Untitled.png)

SOLUCIÓN 

Que cada formulario nos envíe un token para verificar que esa petición la está haciendo el propio usuario, ese campo lo vamos a incluir como un campo oculto en los formularios

Ese middleware va a estar buscando un token que va a estar ligado a mi sesión 

Este middleware nos va a poner este método en el request para que generemos un token que esté ligado a nuestra sesión de usuario

Al utilizar el middleware **`csrf`** de **`csurf`**, puedes proteger tus rutas de Cross-Site Request Forgery (CSRF). En este caso, se está protegiendo la ruta **`/auth`** y se está enviando el middleware **`csrf`** como una función de manejo de middleware.

Para que el middleware **`csrf`** funcione correctamente, debes asegurarte de que también hayas configurado **`cookie-parser`**. Como se muestra en el código proporcionado, se está usando **`cookie-parser`** para habilitar el uso de cookies en la aplicación.

Una vez que tienes el middleware **`csrf`** configurado en tu aplicación, debes asegurarte de que cada formulario de tu aplicación incluya un campo de token CSRF. Puedes hacer esto mediante la utilización de la función **`csrfToken`** en el lado del cliente. Por ejemplo, en una plantilla de Handlebars:

```jsx
<form method="POST" action="/auth">
  <input type="hidden" name="_csrf" value="{{csrfToken}}">
</form>
```

Cuando se envía el formulario, el middleware **`csrf`** verificará que el token enviado coincide con el token almacenado en la cookie y, si es así, permitirá que la solicitud continúe. Si hay una discrepancia, se generará un error **`Forbidden`** y se rechazará la solicitud.

Espero que esto ayude a aclarar cómo funciona el middleware **`csrf`** y cómo se puede utilizar para proteger tu aplicación de ataques CSRF. Si tienes alguna pregunta adicional, no dudes en hacerla.

# Notas 2.0
Pues lo que entendi es que esta vulnerabilidad queda obsoleta al hacer que nuestras apis respondan con json, por lo que solo tendriamos que preocuparnos de esta en caso de usar templates engines

# Referencias
[Understanding CSRF](https://github.com/pillarjs/understanding-csrf)  
[double submit cookie pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie)